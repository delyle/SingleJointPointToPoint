% fit nlm to data

% Plot from parameter sweep (currently only for VelActFmaxStiffSweep)
blankSlate
% load data
mainDir = 'TrackO1ParamSweep/VelActFmaxStiffSweep/Data_45to135_flat_T0p4_warmstart';%
fList = dir([mainDir,'/Data_*.mat']);
[A,S] = loadTrackO1Solutions(mainDir);
saveFig = true;
saveFigDir = []; % if empty, will save to mainDir

fprintf('Parameter range:\n----------------------\n')
disp(['c1: ',sprintf('\t%.2f',S.c1_range)])
disp(['act: ',sprintf('\t%.0f  ',S.act_range*1000),'  ms'])
disp(['deact: ',sprintf('\t%.0f  ',S.deact_range*1000),'  ms'])
disp(['Vmax: ',sprintf('\t%.2f  ',S.Vmax_range)])
disp(['Fmax: ',sprintf('\t%.0f  ',S.Fmax_range)])

%% load performance data

objType = 'sse';
recomputeRMSE = true;
switch lower(objType)
    case 'work'
        JField = 'J_sol';
        cbarTxt = 'Work (J)';
    case 'sse'
        JField = 'J_trackErr_sol';
        recomputeRMSE = true;
        cbarTxt = 'RMSE (l_0)';
end
% load cost data
[meanCoact,J] = deal(NaN(size(S.c1Mat)));
for i = 1:numel(S.c1Mat)
    if ~isempty(A(i).(JField)) % && isfield(A(i),'J_trackErr_sol')
    J(i) = A(i).(JField);


    act = A(i).x_t([3,6],:);
    coact = min(act);
    meanCoact(i) = mean(coact);
    end
end
if recomputeRMSE
% recompute into RMSE
J = sqrt(A(1).Psim.dt/A(1).Psim.T*J)/A(1).Psim.lO/2; % get the root-mean-squared error for one muscle (it will be the same for the other).
end

% Normalise data

Nfun = @(v) (v-min(v))./range(v); % normalizes a matrix's columns to be on [0 1];

Xraw = [S.deactMat(:),S.c1Mat(:),S.actMat(:),S.VmaxMat(:),S.FmaxMat(:)];

X = Nfun(Xraw); 
y = Nfun(J(:));

%% test linear model; should be the same
% terms matrix
Tlmfull = zeros(16,6); % need extra column of zeros for response variable
Tlmfull(2:6,1:5) = eye(5); % single terms; start at 2 to include intercept
Tlmfull(7:end,1:5) = [
    1 1 0 0 0
    1 0 1 0 0
    1 0 0 1 0
    1 0 0 0 1
    0 1 1 0 0
    0 1 0 1 0
    0 1 0 0 1
    0 0 1 1 0 
    0 0 1 0 1
    0 0 0 1 1]; %interaction terms

Xtable = array2table([X,y],'VariableNames',{'Deact','Stiff','Act','Vmax','Fmax','RMSE'});

lmFull = fitlm(Xtable,Tlmfull)

%% display in a better way

dispArray = [lmFull.Coefficients.Estimate(:),lmFull.Coefficients.SE(:).*sqrt(lmFull.NumObservations)];
dispTable = array2table(dispArray,'RowNames',lmFull.CoefficientNames,'VariableNames',{'Estimate','SD'});

%for i = 1:size(dispArray,1)
disp(dispTable)
fprintf('\n\n')
fprintf('% .0e\t\t% .0e\n',dispArray')


%% Show that setting (de)activations to zero, and all other terms to 1 is approximately zero (minimal RMSE)

setTerms = [0;1;0;1;1;0;0;0;0;0;1;1;0;0;1];

fprintf('alphas = 0, all other terms 1, multiply by coefficients, result:\n%.4f\n',sum(dispArray(2:end,1).*setTerms)+dispArray(1))


%% test linear model; only first order terms
% terms matrix
TlmFO = zeros(16,6); % need extra column of zeros for response variable
TlmFO(4:6,3:5) = eye(3); % single terms; start at 4 to avoid deact, stiff
TlmFO(7,1:5) = [
    1 1 0 0 0]; %interaction terms

lm = fitlm(Xtable,TlmFO)

%% display in a better way

dispArray = [lm.Coefficients.Estimate(:),lm.Coefficients.pValue(:)];
dispTable = array2table(dispArray,'RowNames',lm.CoefficientNames,'VariableNames',{'Estimate','pValue'});

%for i = 1:size(dispArray,1)
disp(dispTable)
fprintf('\n\n')
fprintf('% .0e\t\t% .0e\n',dispArray')



%% Test linear model, but only do Fmax, vmax and activation and no interactive effects
XtableAFV = Xtable(:,3:end)

TlmAFV = zeros(7,4); % need extra column of zeros for response variable
TlmAFV(2:4,1:3) = eye(3); % only activation, fmax and vmax terms are included

lm = fitlm(XtableAFV,TlmAFV)


%% adjust coefficients to new range

DataInfo = load([mainDir,'/',fList.name]);
FmaxChange = 0.7;
VmaxChange = 0.7;
actChange = 1.2;
deactChange = 1.2;
stiffChange = 2;

newRangeFun = @(baseline,relChange) sort(baseline*[1 relChange]);

FmaxRange = newRangeFun(DataInfo.baselineFmax,FmaxChange);
VmaxRange = newRangeFun(DataInfo.baselineVmax*2,VmaxChange);
actRange = newRangeFun(DataInfo.baseline_act,actChange);
deactRange = newRangeFun(DataInfo.baseline_deact,deactChange);
stiffRange = newRangeFun(DataInfo.baseline_c(1),stiffChange);

newRange = [deactRange;stiffRange;actRange;VmaxRange;FmaxRange];

oldRange = range(Xraw);

rangeRatio = diff(newRange,1,2)'./oldRange;

%% now do from scratch, just using data within "realistic" ranges

within = @(x,range) x >= range(1) & x <= range(2);

iRange = within(S.deactMat(:),deactRange) & within(S.c1Mat(:),stiffRange) ...
    & within(S.actMat(:),actRange) & within(S.VmaxMat(:),VmaxRange) & within(S.FmaxMat(:),FmaxRange);

XrawRealRange = Xraw(iRange,:);

XrealRange = Nfun(XrawRealRange);
yRealRange = y(iRange);

XtableRealRange = array2table([XrealRange,yRealRange],'VariableNames',{'Deact','Stiff','Act','Vmax','Fmax','RMSE'});

lm = fitlm(XtableRealRange,Tlmfull)

% doesn't work because not enough data within realistic ranges.

%% recompute linear model, testing for first-order terms

Xnew = X.*rangeRatio;

T = zeros(16,6); % need extra column of zeros for response variable
T(2:6,1:5) = eye(5); % single terms; start at 2 to include intercept
T(7:end,1:5) = [
    1 1 0 0 0
    1 0 1 0 0
    1 0 0 1 0
    1 0 0 0 1
    0 1 1 0 0
    0 1 0 1 0
    0 1 0 0 1
    0 0 1 1 0 
    0 0 1 0 1
    0 0 0 1 1]; %interaction terms

XtableNew = array2table([Xnew,y],'VariableNames',{'Deact','Stiff','Act','Vmax','Fmax','RMSE'});

lmNew = fitlm(XtableNew,T)

% just use intercept, all single terms except deactivation, and interaction
% between deactivation and stiffness

% terms matrix
T = zeros(16,6); % need extra column of zeros for response variable
T(3:6,2:5) = eye(4); % single terms; start at 3 to avoid deact
T(7,1:5) = [
    1 1 0 0 0]; %interaction terms

lm = fitlm(XtableNew,T)


%% take full linear model and adjust coefficients based on realistic ranges

Tnan = Tlmfull;
Tnan(Tlmfull == 0) = NaN;
coeffMultiplier = prod(Tnan(:,1:5).*rangeRatio,2,'omitnan');

adjustedCoeffs = lmFull.Coefficients.Estimate(:).*coeffMultiplier

fprintf('\n\n')
fprintf('% .0e\n',adjustedCoeffs)

%% do a fit on coactivation

y_coact = Nfun(meanCoact(:))

lm = fitlm(X,y_coact)

%% fit performance against coactivation

lm = fitlm(meanCoact(:),J(:)/max(J(:)))

min(meanCoact(:))
max(meanCoact(:))

close all
figure('color','w')
plot(meanCoact(:),J(:),'k.')

xlabel('Mean Coactivation')
ylabel('J_{RMSE}')